需先完成的任务步骤：获取 USER_ARTICLE_NUMBER 条用户发表的文章（每次获取的文章都不相同）
方案一：性能太差
1、创建一个新表 t_user_article，用于存储 文章展示集合
2、第一次获取 USER_ARTICLE_NUMBER 条文章数据时，不做任何判断，直接添加
    非第一次获取 USER_ARTICLE_NUMBER 条文章数据时，判断 t_user_article 中是否包含了 这几条数据，
        若包含了其中的 n 条，则重新获取 n 条文章数据，
        反复如此，递归判断 t_user_article 中是否包含了 以上数据，直到没包含为止
3、以此反复

方案二：可能重复出现
1、用的当前最热前2条、当前最新前2条、当前评论最多前1条做为 用户发表的文章的展示

方案三：性能太差
1、对数据库表 t_article 做新增字段 is_read
    第一次获取 USER_ARTICLE_NUMBER 条文章数据时，对 t_article 表中所有数据做 is_read = 0操作，
    随机获取 is_read = 0 的5条数据，将获取到的数据修改为 is_read = 1
        非第一次获取 USER_ARTICLE_NUMBER 条文章数据时，随机获取 is_read = 0 的随机5条数据，将获取到的数据修改为 is_read = 1
2、以此反复

方案四：性能较好
1、第一次获取 USER_ARTICLE_NUMBER 条文章数据时，不做任何判断，将 文章对象 添加进 redis 数据库中
2、非第一次获取 USER_ARTICLE_NUMBER 条文章数据时，将获取到的数据与 redis 中存储的数据进行比对，
        一致的数据重新获取，并递归判断是否重复与是否需要再重新获取
3、以此反复

方案五：性能较好
1、第一次获取 USER_ARTICLE_NUMBER 条文章数据时，不做任何判断，将 文章id 添加进 redis 数据库中
2、非第一次获取 USER_ARTICLE_NUMBER 条文章数据时，将 获取到的文章id 与 redis 中存储的 文章id 进行比对，
        一致的id 重新获取，并递归判断是否重复与是否需要再重新获取
3、以此反复











该项目给我的意义（好处）：
1、关于代码和数据库的编写：
    编码过程更加规范，知道pojo还可以细分为vo、dto等；
    没事还是别做太多表好，别老是一添加新字段就新创关联表，而是考虑需不需做表的修改（新增字段）；
    关于mapper映射文件中，编写SQL的属性还得多加练习且规范

2、











